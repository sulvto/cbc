options {
    STATIC = false;
    DEBUG_PARSER = true;
    UNICODE_INPUT = true;
    JDK_VERSION = "1.8";
}

// 保留字
TOKEN : {
        <VOID : "void">
    | <CHAR : "char">
    | <SHORT : "short">
    | <INT : "int">
    | <LONG : "long">
    | <STRUCT : "struct">
    | <UNION : "union">
    | <ENUM : "ENUM">
    | <STATIC : "static">
    | <EXTERN : "extern">
    | <CONST : "const">
    | <SIGNED : "signed">
    | <UNSIGNED : "unsigned">
    | <IF : "if">
    | <ELSE : "else">
    | <SWITCH : "switch">
    | <CASE : "case">
    | <DEFAULT_ : "default">
    | <WHILE : "while">
    | <DO : "do">
    | <FOR : "for">
    | <RETURN : "return">
    | <BREAK : "break">
    | <CONTINUE : "continue">
    | <GOTO : "goto">
    | <TYPEDEF : "typedef">
    | <IMPORT : "import">
    | <SIZEOF : "sizeof">
}

// 标识符
TOKEN : {
    <IDENTIFIER : ["a"-"z","A"-"Z","_"](["a"-"z","A"-"Z","_","0"-"9"])>
}

// 数值
TOKEN : {
    <INTEGER : ["0"-"9"] (["0"-"9"])* ("U")? ("L")?
            | "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+("U")?("L")?
            | "0" (["0"-"7"])*("U")?("L")?
    >
}

// 字符串
MORE:{<"\""> : IN_STRING }
<IN_STRING> MORE : {
     <(~["\"","\\","\n","\r"])+>
    |<"\\" (["0" - "7"]){3}>
    |<"\\" ~[]>
}
<IN_STRING> TOKEN : {<SPACES: "\"">:DEFAULT}

// 字符
MORE:{<"\'"> : IN_STRING }
<IN_STRING> MORE : {
     <(~["\'","\\","\n","\r"])> : CHARACTER_TERM
    |<"\\" (["0" - "7"]){3}>    : CHARACTER_TERM
    |<"\\" ~[]>                 : CHARACTER_TERM
}
<CHARACTER_TERM> TOKEN :{<CHARACTER:"'" > : DEFAULT}

// 跳过空白符
SPECIAL_TOKEN : {<SPACES : ([" ","\t","\n","\r","\f"])+>}

// 跳过行注释
SPECIAL_TOKEN : {<LINE_COMMENT : "//" (~["\n","\r"])* ("\n" | "\r\n" | "\r")?>}

// 跳过块注释
MORE :{ <"/*"> : IN_BLOCK_COMMENT }
<IN_BLOCK_COMMENT> MORE: {<~[]>}
<IN_BLOCK_COMMENT> SPECIAL_TOKEN:{ <IN_BLOCK_COMMENT : "*/"> : DEFAULT}

AST compilation_unit():
{
    Token t;
    Declarations impdecls,decls;
}
{
    {
        t = getToken(1);
    }
    impdecls=import_stmts() decls=top_defs() <EOF>
    {
        decls.add(impdecls);
        return new AST(location(t),decls);
    }
}

Declarations import_stmts():
{
    String libid;
    Declarations impdecls = new Declarations();
}
{
    (libid=import_stmt()
        {
            try{
                Declarations decls = loader.loadLibrary(libid,errorHandler);
                if(decls!=null){
                    impdecls.add(decls);
                    addKnownTypedefs(decls.typedefs());
                }
            }catch(ComplieException ex){
                throw new ParseException(ex.getMessage());
            }
        }
    )*
    {
        return impdecls;
    }
}

String import_stmt():{}
{
    <IMPORT> name()("." name())* ";"
}

String name():{}
{
    <IDENTIFIER>
}

Declarations top_defs():
{
    Declarations decls = new Declarations();
    DefinedFunction defun;
    List<DefinedVariable> defvars;
    Constant defconst;
    StructNode defstruct;
    UnionNode defunion;
    TypedeNode typedef;
}
{
    (LOOKAHEAD(storage() typeref() <IDENTIFIER> ")")
      defun=defun()        { decls.addDefun(defun); }
    | LOOKAHEAD(3)
      defvars=defvars()    { decls.addDefvars(defvars); }
    | defconst=defconst()  { decls.addDefconst(defconst); }
    | defstruct=defstruct(){ decls.addDefstruct(defstruct); }
    | defunion=defunion()  { decls.addDefunion(defunion); }
    | typedef=typedef()    { decls.addTypedef(typedef); }
    )*
    {
        return decls;
    }
}

List<DefinedVariable> defvars():
{
    List<DefinedVariable> defs = new ArrayList<DefinedVariable>();
    boolean priv;
      TypeNode type;
      String name;
      ExprNode init = null;
}
{
    priv=storage() type=type() name=name() ["=" init=expr()]
    {
        defs.add(new DefinedVariable(priv,type,name,init));
        init = null;
    }
    ("," name=name() ["=" init=expr()]
        {
            defs.add(new DefinedVariable(priv,type,name,init));
            init = null;
        }
    )* ";"
    {
        return defs;
    }
}

String storage():{}
{
    [<STATIC>]
}

DefinedFunction defun():
{
    boolean priv;
    TypeRef ret;
    String n;
    Params ps;
    BlockNode body;
}
{
    priv=storage() ret=typeref() n=name() "(" ps=params() ")" body=block()
    {
        TypeRef t = new FunctionTypeRef(ret,ps.parametersTypeRef());
        return new DefinedFunction(priv,new TypeNode(t),n,ps,body);
    }
}

String parsms():{}
{
     LOOKAHEAD(<VOID> ")") <VOID>
   | fixedparams() ["," "..."]
}

String fixedparams():{}
{
    param() (LOOKAHEAD(2) "," param())*
}

String param():{}
{
    type() name()
}

BlockNode block():
{
    Token t;
    List<DefinedVariable> vars;
    List<StmtNoode> stmts;
}
{
    t="{" vars=defvar_list() stmts=stmts() "}"
    {
        return new BlockNode(location(t),vars,stmts);
    }
}

List<DefinedVariable> defvar_list():
{
    List<DefinedVariable> result = new ArrayList<DefinedVariable>();
    List<DefinedVariable> vats;
}
{
    (vars=defvars(){ result.addAll(vars); })*
    {
        return result;
    }
}

String  defstruct():{}
{
    <STRUCT> name() member_liat() ";"
}

String defunion():{}
{
    <UNION> name() member_list() ";"
}

String member_list():{}
{
    "{" (slot() ";")* "}"
}

String slot():{}
{
    type() name()
}

String typedef() :{}
{
    <TYPEDEF> typeref() <IDENTIFIER> ";"
}

String type():{}
{
    typeref()
}

String typeref():{}
{
    typeref_base()
        ( LOOKAHEAD(2) "[" "]"
        | "[" <INTEGER> "]"
        | "*"
        | "(" param_typerefs() ")"
        )*
}

String typeref_base():{}
{
     <VOID>
   | <CHAR>
   | <SHORT>
   | <INT>
   | <LONG>
   | LOOKAHEAD(2) <UNSIGNED> <CHAR>
   | LOOKAHEAD(2) <UNSIGNED> <SHORT>
   | LOOKAHEAD(2) <UNSIGNED> <INT>
   | <UNSIGNED> <LONG>
   | <STRUCT> <IDENTIFIER>
   | <UNION> <IDENTIFIER>
   | LOOKAHEAD({isType(getToken(1).image)})<IDENTIFIER>
}


List<StmtNode> stmts ():
{
    List<StmtNode> ss = new ArrayList<StmtNode>();
    StmtNode s;
}
{
    (s=stmt(){ if(s!=null) ss.add(s);})*
    {
        return ss;
    }
}

String  stmt():{}
{
    (";"
    | LOOKAHEAD(2) labeled_stmt()
    | expr() ";"
    | bolck()
    | if_stmt()
    | while_stmt()
    | dowhile_stmt()
    | for_stmt()
    | switch_stmt()
    | continue_stmt()
    | goto_stmt()
    | return_stmt()
    )
}

IfNode if_stmt():
{
    Token t;
    ExprNode cond;
    StmtNode thenBody,elseBody = null;
}
{
    t=<IF> "(" cond=expr() ")" thenBody=stmt()
            [LOOKAHEAD(1) <ELSE> elseBody=stmt()]
            {
                return new IfNode(location(t),cond,thenBody,elseBody);
            }
}

WhileNode while_stmt():
{
    Token t;
    ExprNode cond;
    StmeNode body;
}
{
    t=<WHILE> "(" cond=stmt() ")" body=stmt()
    {
        return new WhileNode(location(t),cond,body);
    }
}

String for_stmt():{}
{
    <FOR> "(" [expr()] ";" [expr()] ";" [expr()] ")" stmt()
}

String break_stmt():{}
{
    <BREAK> ";"
}

String return_stmt():{}
{
    LOOKAHEAD(2) <RETURN> ";"
   | <RETURN> expr() ";"
}

ExprNode expr():
{
    ExpeNode lhs,rhs,expr;
    String op;
}
{
     LOOKAHEAD(term() "=")
     lhs=term() "=" rhs=expr()
     {
        return new AssignNode(lhs,rhs);
     }
    | LOOKAHEAD(term() opassign_op())
     lhs=term() op=opassign_op() rhs=expr()
     {
        return new OpAssignNode(lhs,op,rhs);
     }
    | expr=expr10()
     {
        return expr;
     }
}

String opassign_op():{}
{
    ( "+="  {return "+";}
    | "-="  {return "-";}
    | "*="  {return "*";}
    | "/="  {return "/";}
    | "%="  {return "%";}
    | "&="  {return "&";}
    | "^="  {return "^";}
    | "<<=" {return "<<";}
    | ">>=" {return ">>";}
    )
}

ExprNode expr10():
{
    ExprNode c,t,e;
}
{
    c=expr9()["?" t=expr() ":" e=expr10(){ return new CondExprNode(c,t,e); }]
    {
        return c;
    }
}

ExprNode expr9():
{
    ExprNode l,r;
}
{
    l=expr8() ("||" r=expr8(){ l = new LogicalOrNode(l,r); })*
    {
        return l;
    }
}

ExprNode expr8():
{
    ExprNode l,r;
}
{
    l=expr7() ("&&" r=expr7(){ l = new LogicalAndNode(l,r); })*
    {
        return l;
    }
}

ExprNode expr7():
{
    ExprNode l,r;
}
{
    expr6()( ">" expr6()
            | "<" expr6()
            | ">=" expr6()
            | "<=" expr6()
            | "==" expr6()
            | "!=" expr6()
            )*
}

ExprNode expr6():{}
{
    expr5()("||" expr5())
}

ExprNode expr5():{}
{
    expr4()("^" expr4())
}

ExprNode expr4():{}
{
    expr3()("&" expr3())
}

ExprNode expr3():{}
{
    expr2()(  "<<" expr2()
            | ">>" expr2()
            )*
}

ExprNode expr2():
{
    ExprNode l,r;
}
{
    l=expr1() ( "+" r=expr1() { l= new BinaryOpNode(l,"+",r); }
              | "-" r=expr1() { l= new BinaryOpNode(l,"-",r); }
              )*
              {
                return l;
              }
}

ExprNode expr1():
{
    ExprNode l,r;
}
{
    l=term() ( "*" r=term() { l = new BinaryOpNode(l,"*",r); }
             | "/" r=term() { l = new BinaryOpNode(l,"/",r); }
             | "%" r=term() { l = new BinaryOpNode(l,"%",r); }
             )*
             {
                return l;
             }
}

ExprNode term():
{
    TyoeNode t;
    ExprNode n;
}
{
     LOOKAHEAD("(" type())
      "(" t = type() ")" n = term(){ return new CastNode(t,n);}
   | unary()                       { return n;}
}

ExprNode unary():
{
    ExprNode n;
    TypeNode t;
}
{
     "++" n=unary() { return new PrefixOpNode("++",n);}
   | "--" n=unary() { return new PrefixOpNode("--",n);}
   | "+"  n=term()  { return new UnaryOpNode("+",n);}
   | "-"  n=term()  { return new UnaryOpNode("-",n);}
   | "!"  n=term()  { return new UnaryOpNode("!",n);}
   | "~"  n=term()  { return new UnaryOpNode("~",n);}
   | "*"  n=term()  { return new DereferenceNode(n);}
   | "&"  n=term()  { return new AddressNode(n);}
   | LOOKAHEAD(3) <SIZEOF> "(" y=type() ")"
     {
           return new SizeofTypeNode(t,sizr_t());
     }
   | <SIZEOF> n=unary()
     {
         return new SizeofExprNode(n,sizr_t());
     }
   | n=postfix() { return n; }
}

ExprNode postfix():
{
    ExprNode expr,idx;
    String memb;
    List<ExprNode> args;
}
{
    expr = primary()
    ( "++"               { expr = new SuffixOpNode("++",expr); }
    | "--"               { expr = new SuffixOpNode("--",expr); }
    | "[" ind=expr() "]" { expr = new ArefNode(expr,idx); }
    | "." memb=name()    { expr = new MemberNode(expr,memb); }
    | "->" memb=name()   { expr = new PtrMemberNode(expr,memb); }
    | "(" args=args() ")"{ expr = new FuncallNode(expr,args); }
    )*{
        return expr;
    }
}

String args():{}
{
    [expr() ("," expr())* ]
}

ExprNode primary():
{
    Token t;
    ExprNode n;
}
{
     t=<INTEGER>
     {
        return integerNode(location(t),t.image);
     }
   | t=<CHARACTER>
     {
           return new IntegerLiteralNode(location(t),IntegerTypeRef.charRef(),characterCode(t.image));
     }
   | t=<STRING>
      {
        return new StringLiteralNode(location(t),new PointerTypeRef(IntegerTypeRef.charRef()),stringValue(t.image));
      }
   | t=<IDENTIFIER>
     {
        return new VariableNode(location(t),t.image);
     }
   | "(" expr() ")"
    {
        return n;
    }
}